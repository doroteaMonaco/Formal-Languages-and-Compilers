import java_cup.runtime.*;
import java.io.*;
import java.util.HashMap;


init with {:
    // buffer che conterrà l'output program
    outputBuffer = new StringBuffer();
    errorBuffer = new StringBuffer();
:};


parser code {:

    HashMap<String, SymbolType> SymbolType_table = new HashMap<String, SymbolType>();

    // numero della first usable label
    public int label = 0;

    // file di output (stdout oppure file [to dumb program in a file])
    public static String dumpOutput;

    // true se il semantic check è attivo
    public boolean enableSem = true;

    public int semError = 0;
    public int semWarnings = 0;
    public int synWarnings = 0;
    // string buffer per l'output program (inizializzato sopra con init)
    public StringBuffer outputBuffer;
    public StringBuffer errorBuffer;
    // generazione del numero della next label
    public int genLabel(){
        label++;
        return label;
    }
    
    // Redefinition of error functions
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    public void syntax_error(Symbol cur_token){}

    // ritorna actual symbol (tos = top of stack) [dalla teoria]
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }

    // ritorna il semantic value del simbolo alla posizione pos [dalla teoria]
    public Object stack(int pos) {
        return (((Symbol)stack.elementAt(tos + pos)).value);
    }

    // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }

    // Classe SymbolType minima per compilazione
    class SymbolType {
        private int type;
        private int dim;
        public SymbolType(int type, int dim) {
            this.type = type;
            this.dim = dim;
        }
        public int getType() { return type; }
        public int getDim() { return dim; }
        public String getName() {
            if(type == 0) return "INT";
            if(type == 1) return "DOUBLE";
            return "UNDEFINED";
        }
    }
:};


action code {:

    class Expr{
        private String value;
        private SymbolType type;

        private SymbolType lookupSymbolType(String id) {
            SymbolType st = parser.SymbolType_table.get(id);
            if (st == null) {
                pSemError("Symbol '" + id + "' not declared");
                return new SymbolType(-1, -1);
            }
            return st;
        }

        Expr(String value, SymbolType type) {
            this.value = value;
            this.type = type;
        }

        Expr(String value) {
            this.value = value;
            this.type = lookupSymbolType(value); // tipo non definito
        }

        Expr(String value, Integer pos) {
            this.value = value+"["+pos.toString()+"]";
            this.type = lookupSymbolType(value);
            int dim = type.getDim();
            if(pos >= dim && dim != -1) {
                pSemError("Index out of bounds for array '" + value + "': " + pos);
            }
        }

        Expr(String value, String pos) {
            this.value = value+"["+pos+"]";
            this.type = lookupSymbolType(value);
        }

        public String toString() {
            return value;
        }

        public SymbolType getSymbolType() {
            return type;
        }

        public SymbolType checkType(Expr e){
            int type1 = type.getType();
            int type2 = e.getSymbolType().getType();
            if(type1 == type2){
                return type;
            } else if (type1 != -1 && type2 != -1) {
                pSemWarning("Type mismatch: " + type.getName() + " and " + e.getSymbolType().getName());
                return new SymbolType(-1, -1); // tipo non definito
            }
            else{
                return new SymbolType(-1, -1); // tipo non definito
            }
        }

        public void checkSymbolTypeAssignment(Expr e){
            int type1 = type.getType();
            int type2 = e.getSymbolType().getType();
            if(type1 == 0 && type2 == 1){
                 pSemWarning("Assignment from DOUBLE to INT: " + type.getName() + " to " + e.getSymbolType().getName());
            } else if (type1 == 1 && type2 == 0) {
                pSemWarning("Assignment from INT to DOUBLE: " + type.getName() + " to " + e.getSymbolType().getName());
            }
        }
    }


    // disabilita semantic check
    private void disableSem() {
        parser.enableSem = false;
    }
    // ritorna true se semantic check è attivo (o no)
    private boolean sem() {
        return parser.enableSem;
    }

    // Error Management
    private void pSemError(String message){
        parser.errorBuffer.append("SEM ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message+"\n");
        parser.semError++;
    }
    private void pSemWarning(String message){
        parser.errorBuffer.append("SEM WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message+"\n");
        parser.semWarnings++;
    }
    private void pSynError(String message){
        System.err.println("SYN ERROR: line:"+parser.getLine()+" col:"+parser.getColumn()+": "+message);
        System.err.println("Could not continue parsing");
        parser.done_parsing();
    }
    private void pSynWarning(String message){
        parser.errorBuffer.append("SYN WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message+"\n");
        parser.synWarnings++;
        disableSem(); // se c'è errore sintattico disabilito semantica
    }

    // scrive una String in output
    private void dump(String s){
        if(parser.dumpOutput == "stdout") {System.out.print(s);}
        else {parser.outputBuffer.append(s);}
    }
    private void dumpln(String s){
        if(parser.dumpOutput == "stdout") System.out.println(s);
        else parser.outputBuffer.append(s+"\n");
    } 
:}


// Terminal tokens
terminal Integer INT;
terminal Double DOUBLE;

terminal PRINT, IF, WHILE, THEN, ELSE;
terminal String ID;
terminal RO, RC, BO, BC, S, CM, SO, SC;
terminal PLUS, MINUS, STAR, DIV;
terminal MIN, MAJ, MIN_EQ, EQ_MIN, MAJ_EQ, EQ_MAJ, EQ;
terminal AND, OR, NOT;
terminal INT_TYPE, DOUBLE_TYPE;
terminal UMINUS, LOWER_THAN_ELSE;


// Non terminal tokens
non terminal prog, stmt_list, stmt, assignment, print, if;
non terminal mineq, majeq;
non terminal Expr id;
non terminal Expr exp;

// aggiunti non-terminal
non terminal Integer[] nt0_while;
non terminal Integer nt0_if, nt1_if;
non terminal while; // non serve più: non terminal if;

non terminal decl_list, decl, var_list, var;
non terminal String type, array;
non terminal String if_condition, while_condition;

// aggiunti per risolvere i conflitti
non terminal matched_stmt, unmatched_stmt;

// Precedences and associativities
// lower precedences
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left MIN, MAJ, MIN_EQ, EQ_MIN, MAJ_EQ, EQ_MAJ, EQ;
precedence left PLUS, MINUS;
precedence left STAR, DIV;
precedence left UMINUS;
// aggiunta per evitare il dangling else (dare priorità allo shift sull'ELSE)
precedence nonassoc LOWER_THAN_ELSE;
precedence nonassoc ELSE;
// higher precedences


//////////////////////////////////////
// Grammar start
//////////////////////////////////////

start with prog;


prog ::= decl_list stmt_list {:
                if(sem() && parser.semError == 0) {
                    dumpln("\n// Program successfully parsed");
                    if (parser.dumpOutput == "stdout") {
                        System.out.println(parser.outputBuffer.toString());
                    } else {
                        try {
                            BufferedWriter writer = new BufferedWriter(new FileWriter(parser.dumpOutput));
                            String output = parser.outputBuffer.toString();
                            writer.write(output);
                            writer.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        
                    }
                } else {
                    System.err.println("\n// Program parsing failed with " + parser.semError + " errors and " + parser.semWarnings + " warnings.");
                }
                System.err.println(parser.errorBuffer);
                System.err.println("Total syntax warnings: " + parser.synWarnings);
                System.err.println("Total semantic errors: " + parser.semError);
                System.err.println("Total semantic warnings: " + parser.semWarnings);
:}
;


//////////////////////////////////////
// Declarations
//////////////////////////////////////

decl_list ::= decl_list decl
            | /* empty */
;

decl ::= type var_list S
    | type error S {: pSynWarning("Error in declaration"); :}
;

type ::= INT_TYPE {: if(sem()) RESULT = new String("INT"); :}
        | DOUBLE_TYPE {: if(sem()) RESULT = new String("DOUBLE"); :}
;

var_list ::= var 
    | var_list CM {: if(sem()) RESULT = parser.stack(-2); :} var
;

var ::= ID:x {: if(sem()) {
    dumpln("\t"+parser.stack(-1) + " " + x);
    if(parser.stack(-1).equals("INT")) {
        parser.SymbolType_table.put(x, new SymbolType(0, 1)); // INT type
    } else if(parser.stack(-1).equals("DOUBLE")) {
        parser.SymbolType_table.put(x, new SymbolType(1, 1)); // DOUBLE type
    }
}:}
| ID:x SO INT:y SC {: if(sem()) {
    dumpln("\t"+parser.stack(-4) + " " + x + "[" + y.toString() + "]");
    if(parser.stack(-4).equals("INT")) {
        parser.SymbolType_table.put(x, new SymbolType(0, y)); // INT array
    } else if(parser.stack(-4).equals("DOUBLE")) {
        parser.SymbolType_table.put(x, new SymbolType(1, y)); // DOUBLE array
    }
}:}
;


//////////////////////////////////////
// Instructions
//////////////////////////////////////

stmt_list ::= stmt_list stmt 
            | stmt 
            | error stmt {: pSynWarning("Error in statement"); :}
;

stmt ::= matched_stmt | unmatched_stmt
    | BO stmt_list error BC {: pSynWarning("Missing ; before }"); :}
    | BO error BC {: pSynWarning("Missing ; before }"); :}
    | error S {: pSynWarning("Error in statement"); :}
;

// matched_stmt: tutte le istruzioni tranne gli if unmatched
matched_stmt ::= IF if_condition nt0_if matched_stmt ELSE nt1_if matched_stmt {:
                    if (sem()) {dump("L" + parser.stack(-1) + ":");}
                :}
              | while
              | assignment
              | print
              | BO stmt_list BC
;

// unmatched_stmt: solo gli if senza else o annidati
unmatched_stmt ::= IF if_condition nt0_if matched_stmt {: if (sem()) {dump("L" + parser.stack(-1) + ":");} :} %prec LOWER_THAN_ELSE
                 | IF if_condition nt0_if unmatched_stmt ELSE nt1_if matched_stmt {: if (sem()) {dump("L" + parser.stack(-1) + ":");} :}
;

// Assignment instruction
assignment ::= id:x S {: if (sem()) {dumpln("\t" + x);} :}
    | id:x EQ exp:y S {: if (sem()) {x.checkSymbolTypeAssignment(y); dumpln("\tEVAL "+y+"\n\tASS "+x);} :}
    | id EQ error S {: pSynWarning("Error in expression"); :}
    | error EQ exp S {: pSynWarning("Error in assigment"); :}
;


// PRINT instruction
print ::= PRINT id:x S {: if (sem()) {dumpln("\tPRINT " + x);} :}
          | PRINT error S {: pSynWarning("Error in 'print' instruction"); :}
;



if ::= IF if_condition nt0_if stmt ELSE nt1_if stmt {:
                                if (sem()) {dump("L" + parser.stack(-1) + ":");}
        :}
     | IF if_condition:e nt0_if stmt {:
                                if (sem()) {dump("L" + parser.stack(-1) + ":");}
        :}
     | IF if_condition:e nt0_if stmt error nt1_if stmt {: pSynWarning("Error 'else' expected in 'if' instruction"); :}
;

if_condition ::= RO exp:e RC {: if(sem()) RESULT=e.value; :}
    | RO error RC {: pSynWarning("Error in 'if' condition"); :}
    | error exp RC {: pSynWarning("Error '(' expected in 'if' instruciton"); :}
    | RO exp error  {: pSynWarning("Error ')' expected in 'if' instruciton"); :}
;

nt0_if ::= {:
        if (sem()) {
            RESULT = parser.genLabel();
            dumpln("\tEVAL " + parser.stack(0) + "\t\t/* if (line " + parser.getLine() + ") */\n\tGOTOF L" + RESULT);
        }
:}
;

nt1_if ::= {:
        if (sem()) {
            RESULT = parser.genLabel();
            dumpln("\tGOTO L" + RESULT);
            dump("L" + parser.stack(-2) + ":");
        }
:}
;

// WHILE instruction
while ::= WHILE while_condition nt0_while stmt {:
                    if (sem()) {
                        Integer[] l = (Integer[])parser.stack(-1);
                        dumpln("\tGOTO L" + l[0]);
                        dump("L" + l[1] + ":");
                    }
:}
;

while_condition ::= RO exp:e RC {: if(sem()) RESULT=e.value; :}
    | RO error RC {: pSynWarning("Error in 'while' condition"); :}
    | error exp RC {: pSynWarning("Error '(' expected in 'while' instruciton"); :}
    | RO exp error  {: pSynWarning("Error ')' expected in 'while' instruciton"); :}
;

nt0_while ::= {:
        if (sem()) {
            RESULT = new Integer[2];
            RESULT[0] = (Integer)parser.genLabel();
            RESULT[1] = (Integer)parser.genLabel();
            dumpln("L" + RESULT[0] + ":\tEVAL " + parser.stack(0) + "\t\t/* while (line " + parser.getLine() + ") */\n\tGOTOF L" + RESULT[1]);
        }
:}
;


// Expressions
exp ::= 
    /* Logical expressions */
    exp:x AND exp:y {: if(sem()) RESULT = new Expr(x+" "+y+"&", x.checkType(y));:}
    | exp:x OR exp:y {:if(sem()) RESULT = new Expr(x+" "+y+"|", x.checkType(y)); :}
    | NOT exp:x {: if(sem()) RESULT = new Expr(x+"!", x.getSymbolType()); :}

    /* Comparison expressions */
    | exp:x EQ EQ exp:y {: if(sem()) RESULT = new Expr(x+" "+y+"==", x.checkType(y)); :}
    | exp:x MIN exp:y {: if(sem()) RESULT = new Expr(x+" "+y+"<", x.checkType(y)); :}
    | exp:x MAJ exp:y {: if(sem()) RESULT = new Expr(x+" "+y+">", x.checkType(y));; :}
    | exp:x mineq exp:y {: if(sem()) RESULT = new Expr(x+" "+y+"<=", x.checkType(y)); :}
    | exp:x majeq exp:y {: if(sem()) RESULT = new Expr(x+" "+y+">=", x.checkType(y)); :}

    /* Arithmetic expression */
    | exp:x PLUS exp:y {: if(sem()) RESULT = new Expr(x+" "+y+"+", x.checkType(y)); :}
    | exp:x MINUS exp:y {: if(sem()) RESULT = new Expr(x+" "+y+"-", x.checkType(y)); :}
    | exp:x STAR exp:y {: if(sem()) RESULT = new Expr(x+" "+y+"*", x.checkType(y)); :}
    | exp:x DIV exp:y {: if(sem()) RESULT = new Expr(x+" "+y+"/", x.checkType(y)); :}
    | RO exp:x RC {: if(sem()) RESULT = x; :}
    | id:x {: if(sem()) RESULT = x; :}
    | INT:x {: if(sem()) RESULT = new Expr(x.toString(), new SymbolType(0,1)); :}
    | DOUBLE:x {: if(sem()) RESULT = new Expr(x.toString(), new SymbolType(1,1)); :}
    | MINUS INT:x {: if(sem()) RESULT = new Expr("-"+x.toString(), new SymbolType(0,1)); :} %prec UMINUS
    | MINUS DOUBLE:x {: if(sem()) RESULT = new Expr("-"+x.toString(), new SymbolType(1,1)); :} %prec UMINUS
    | RO error RC {: pSynWarning("Error in expression"); :}
;


mineq ::= MIN_EQ | EQ_MIN;
majeq ::= MAJ_EQ | EQ_MAJ;


id ::= ID:x {: if(sem()) RESULT = new Expr(x); :}
      |ID:x SO INT:y SC {: if(sem()) RESULT = new Expr(x, y); :}
      |ID:x SO ID:y SC {: if(sem()) RESULT = new Expr(x, y); :}
      | error SC {: pSynWarning("Error in vector"); :}
;