import java_cup.runtime.*;
import java.io.*;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;

init with {:
    map = new HashMap<String, ArrayList<Room>>();
:};

parser code {:

    HashMap<String, ArrayList<Room>> map = new HashMap();
    
    public class Room {
        private String name;
        private Integer size;

        Room(String name, Integer size) {
            this.name = name;
            this.size = size;
        }

        public String getName() {
            return this.name;
        }

        public Integer getSize() {
            return this.size;
        }
    }

    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    public void syntax_error(Symbol cur_token){}

    // ritorna actual symbol (tos = top of stack) [dalla teoria]
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }

    // ritorna il semantic value del simbolo alla posizione pos [dalla teoria]
    public Object stack(int pos) {
        return (((Symbol)stack.elementAt(tos + pos)).value);
    }

    // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }
:};

action code {:
    //creazione di classi se serve raggruppare
:};

//Simboli da jflex
terminal PV, V, DEQ, P, TA, TC, TOK1, TOK3, TOK2, HOUSE, ST, END, IF, FI, THEN, AND, OR, NOT, PRINT, SEP;
terminal String STR;
terminal Integer INT;
//productions di cup
non terminal prog, if_command, if_list, preference_section, house, house_list, house_section, header;
non terminal String print;
non terminal ArrayList<String> print_list;
non terminal Boolean operand, bool_exp;
non terminal Room room;
non terminal ArrayList<Room> room_list;

//precedenze se servono
precedence left AND, OR;
precedence left NOT;

start with prog;

prog ::=  header SEP house_section SEP preference_section;

header ::= TOK3 TOK2 TOK3 TOK1;

house_section ::= house_list;

house_list ::= house_list house house | house house;

house ::= HOUSE STR:type ST room_list:list END {:
    parser.map.put(type, list);
:};

room_list ::= room_list:list V room:rom {:
    list.add(rom);
    RESULT = list;
:} 
| room:rom {:
    ArrayList<Room> list = new ArrayList();
    list.add(rom);
    RESULT = list;
:};

room ::= STR:name INT:size {:
    Room rom = new Room(name, size);
    RESULT = rom;
:};

preference_section ::= if_list | /*empty*/;

if_list ::= if_list if_command | if_command;

if_command ::= IF bool_exp:bx THEN print_list:list FI {:
    if(bx == true) {
        for(String s: list){
            System.out.println(s);
        }
    }
:};

bool_exp ::= bool_exp:b1 AND bool_exp:b2 {:
    Boolean res = b1&&b2;
    RESULT = res;
:}
|bool_exp:b1 OR bool_exp:b2 {:
    Boolean res = b1||b2;
    RESULT = res;
:}
|NOT bool_exp:bx {:
    Boolean res = !bx;
    RESULT = res;
:}
|TA bool_exp:b1 AND bool_exp:b2 TC {:
    Boolean res = b1&&b2;
    RESULT = res;
:}
|TA bool_exp:b1 OR bool_exp:b2 TC {:
    Boolean res = b1||b2;
    RESULT = res;
:}
|TA NOT bool_exp:bx TC {:
    Boolean res = !bx;
    RESULT = res;
:}
|operand:op {:
    RESULT = op;
:};

operand ::= STR:type P STR:name DEQ INT:size {:
    ArrayList<Room> list = parser.map.get(type);
    Boolean res = true;
    for(Room rom: list){
        if(rom.getName().equals(name)){
            if(rom.getSize().equals(size)){
                res = true;
            }
            else {
                res = false;
            }
        }
    }
    RESULT = res;
:};

print_list ::= print_list:list print:str {:
    list.add(str);
    RESULT = list;
:}
| print:str {:
    ArrayList<String> list = new ArrayList();
    list.add(str);
    RESULT = list;
:};

print ::= PRINT STR:str PV{:
    RESULT = str;
:};